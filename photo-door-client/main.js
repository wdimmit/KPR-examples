/* *     Copyright (C) 2010-2016 Marvell International Ltd. *     Copyright (C) 2002-2010 Kinoma, Inc. * *     Licensed under the Apache License, Version 2.0 (the "License"); *     you may not use this file except in compliance with the License. *     You may obtain a copy of the License at * *      http://www.apache.org/licenses/LICENSE-2.0 * *     Unless required by applicable law or agreed to in writing, software *     distributed under the License is distributed on an "AS IS" BASIS, *     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *     See the License for the specific language governing permissions and *     limitations under the License. */ /* =-====================================================================-= *//* =-=========================== AWS SET-UP =============================-= *//* =-====================================================================-= */import credentials from "credentials"; const bucket = "element-photo-door";const config = { region: "us-west-2", signatureVersion: "s3", systemClockOffset: 0 };let AWS = require("aws");AWS.config = config;let S3 = require("amz").S3;/* =-====================================================================-= *//* =-=========================== UI ELEMENTS ============================-= *//* =-====================================================================-= */let topBarHeight = 40import { 	VerticalScrollerBehavior,	VerticalScroller} from "scroller";import {	leftArrowSkin,	refreshSkin,	trashSkin,	settingTopColor,	whiteSkin,	topBarMainStyle,	photoStyleBelow,	BusyLine,	EmptyLine,	ErrorLine,	PanZoomBehavior,	ListBehavior,	ButtonBehavior,	ListItemBehavior} from "assets";import {	OpenMenuTransition, 	CloseMenuTransition, } from "transitions";export class ScreenGridBehavior extends ListBehavior {	onCreate(list, data) {		this.data = data;		this.flag = true;		this.data.items = null;	}	onSetSelectContainer(list, container) {		this.selectContainer = container;	}	onDisplayed(list) {		this.load(list);	}	addItemLine(list, item) {		if(item.name!=this.deleteFile)			list.add(new PhotosCell(item));		else			this.deleteFile = null;	}	createMessage(list, data) {		trace("createMessage()  "  + (new Date()) + "\n");		let request = { headers:{}, method:"GET", path:"/element-photo-door" };		return S3.createMessage(data, request);	}	getItems(list, message, document) {		let data = this.data;		let objects = [];		trace("getItems "  + (new Date()) + "\n");		let request = { headers:{}, method:"GET", path:"/element-photo-door" };		if (document && document.documentElement) {			let nodes = document.documentElement.getElementsByTagName("Contents");			if (nodes.length > 0) {				objects.length = nodes.length;				for (let i = 0, c = nodes.length; i < c; ++i) {					let name = nodes.item(i).firstChild.firstChild.nodeValue;					objects[i] = { name };				}			}		}		// Note: Amazon S3 returns object keys in UTF-8 binary order.		// This Amazon S3 bucket reverse & slice trick assumes		// there are less than 1000 objects in the bucket,		// otherwise multiple requests are necessary.		objects.reverse();		let MAX_LIST_ITEMS = 20;		if (objects.length > MAX_LIST_ITEMS) {			objects.length = MAX_LIST_ITEMS;		}		let items = [];		items.length = objects.length;		for (let i = 0, c = objects.length; i < c; ++i) {			let name = objects[i].name;			let path = "/element-photo-door/" + name;			let request = { headers:{}, method:"GET", path:path };			let url = S3.presignedExpiresURL(data, request);			items[i] = { name, url };		}		return (items.length ? items: null);	}	onItemTap(list, item) {		super.onItemTap(this, list, item);	}	onSetValue(list,flag,name) {		this.flag = flag;		if(this.flag==true) {			this.data.items = null;			list.cancel();			list.empty();		}		if(name!=null)			this.deleteFile = name;		else			this.deleteFile = null;	}	load(list,more) {		if((!this.data.items) || this.flag==true) {			this.addBusyLine(list);			list.invoke(this.createMessage(list, this.data), Message.DOM);		}	}	addLines(list, items, more) {		var c = items.length;		if (c) {			for (var i = 0; i < c; i++) {				trace(`items[${i}]: ${JSON.stringify(items[i])} \n`);				this.addItemLine(list, items[i], i);			}			if (more)				this.addMoreLine(list);		}		list.adjust();	}	getCellNum(width,height) {		if(width>height)			return 3;		else			return 2;	}	getCellHeight(width) {		return width;	}	onMeasureHorizontally(container, width) {		return width;	}	onMeasureVertically(container, height) {		var content = container.first;		var items = this.data.items;		if (items && items.length) {			var total = container.width;			var c = this.getCellNum(application.width,application.height);			var gutter = 8;			var width = Math.floor((total - ((c + 1) * gutter)) / c);			if (width & 1) width--;			var height = this.getCellHeight(width);			var coordinates = {left:0, width: width, top:0, height: height};			var xs = new Array(c);			var ys = new Array(c);			for (var i = 0; i < c; i++) {				xs[i] = gutter + i * (width + gutter);				ys[i] = gutter;			}			while (content) {				var min = 0x7FFFFFFF;				var j = 0;				for (var i = 0; i < c; i++) {					var y = ys[i];					if (y < min) {						min = y;						j = i;					}				}				coordinates.left = xs[j];				coordinates.top = min;				content.coordinates = coordinates;				ys[j] = min + coordinates.height + gutter;				content = content.next;			}			height = 0;			for (var i = 0; i < c; i++) {				var y = ys[i];				if (y > height)					height = y;			}		}		else if (content) {			height = application.height - topBarHeight - 40;			content.coordinates =  {left:0, right: 0, top:0, bottom: 0};		}		return height;	}}var PhotosCell = Container.template($ => ({	clip: "true", active: "true",	Behavior: class extends ListItemBehavior {		onCreate(container,data) {			super.onCreate(container, data);			this.getTimeInterval(container,this.data.name);		}		onTap(line) {
			let photoShow = new PhotoScreen({});
			photoShow.distribute("onSetValue", this.data.url, this.data.PHOTOTIME.string, this.data.name);			application.run(new OpenMenuTransition, model.photoScreen, photoShow);		}		getTimeInterval(container,time){			var date = new Date;			var offset = date.getTimezoneOffset();			var curTime = date.getTime();			var picTime = parseFloat(time);						var interval = Math.round((curTime - picTime)/1000/60);			var str;			if (interval<60)				str = interval + " minutes ago";			else if (interval < 60*24) {				var hours = Math.floor(interval/60);				var minutes = interval - hours*60;				if (minutes!=0)					str = hours + " hours,"+minutes+" minutes ago" ;				else					str = hours + " hours ago" ;			}			else {				var picDate = new Date;				picDate.setTime(picTime);				var strSplit = picDate.toString().split(":");				str = strSplit[0] + ":" + strSplit[1];			} 						this.data.PHOTOTIME.string = str;		}	},	contents: [		Thumbnail($, {			left: 10, right: 10, top: 10, bottom: 25, url: $.url		}),		Label($, {			anchor: "PHOTOTIME", left: 0, right: 0, bottom: 0, style: photoStyleBelow, string: "",		})		]}));var PhotoList = Scroller.template($ => ({	left: 0, right: 0, top: 0, bottom: 0, skin: whiteSkin,	behavior: Object.create(VerticalScrollerBehavior.prototype,{		onDisplayed:{value:function(content) {			content.focus();		}},		onKeyDown:{value:function(content, key, modifiers, count, tick) { 			var code = key.charCodeAt(0); 			if((code == 8) || (code == 0xF0001)) 				this.data.CLOSEICON.delegate("onTap"); 		}},	}),	contents:[		Container($, {			left: 0, right: 0, top: 0, height: topBarHeight, skin: settingTopColor,			contents:[				Label($,{					anchor:"TITLE",style:topBarMainStyle,string:"Photos",				}),				Container($,{					anchor: "CLOSEICON", left: 0, top: 0, bottom: 0, width: 100, active: true,					Behavior: class extends ButtonBehavior {						onTap(content) {							model.photoScreen.distribute("onSetValue",true);							model.photoScreen.distribute("load");						}					},					contents:[						Content($,{							top: 5, bottom: 5, left: 13, width: 21, height: 21, skin: refreshSkin,						})					],				}),						]		}),		VerticalScroller($,{			left: 0, right: 0, top: topBarHeight, bottom: 0,clip: true, active: true,				contents:[				Layout($, {					anchor:"LIST", left: 0, right: 0, top: 0, active: true, backgroundTouch: true,
					Behavior: ScreenGridBehavior				})							]		})	]}));var PhotoScreen = Container.template($ => ({	name: "photoScreen", left: 0, right: 0, top: 0, bottom: 0, skin: whiteSkin,	Behavior: class extends Behavior {		onCreate(container,data) {			this.data = data;		}		onDisplayed(content) {			content.focus();		}		onKeyDown(content, key, modifiers, count, tick) { 			var code = key.charCodeAt(0); 			if((code == 8) || (code == 0xF0001)) 			this.data.CLOSEICON.delegate("onTap"); 		}	},	contents:[		Container($, {			left: 0, right: 0, top: 0, height: topBarHeight, skin: settingTopColor,			contents:[				Label($,{					anchor:"TITLE",style:topBarMainStyle,string:"Photo",				}),				Container($,{					anchor: "CLOSEICON", left: 0, top: 0, bottom: 0, width: 100, active: true,					Behavior: class extends ButtonBehavior {						onTap(content) {							model.photoScreen.distribute("onSetValue", false);							application.run(new CloseMenuTransition, model.photoScreen);							}					},					contents:[						Content($, {							left: 13, width: 19, height: 25, skin: leftArrowSkin,						})					],				}),				Container($,{					anchor: "TRASHICON", right: 0, top: 0, bottom: 0, width: 100, active: true,					Behavior: class extends ButtonBehavior {						onTap(content) {							trace("Tapped "+this.data.name+"\n");							let request = { headers: {}, method: "DELETE", path: "/element-photo-door/"+this.data.name };							let message = S3.createMessage(data, request);							application.invoke(message, Message.DOM);							model.photoScreen.distribute("onSetValue", true, this.data.name);							application.run(new CloseMenuTransition, model.photoScreen);						}					},					contents:[						Content($, {							right: 13, width: 25, height: 25, skin: trashSkin,						})					],				}),			]		}),		Container($, {			left: 0, right: 0, top: topBarHeight, bottom: 0, clip: true,			contents:[				Picture($, {					anchor: "PHOTO", left: 0, right: 0, top: 0, bottom: 0, multipleTouch: true, active: true,					behavior: new PanZoomBehavior($)				}),			]		}),	]}));/* =-====================================================================-= *//* =-======================== APPLICATION SET-UP ========================-= *//* =-====================================================================-= */let model = application.behavior = Behavior({	onDisplayed(application) {		var photoScreen = this.photoScreen = new PhotoList({});		application.add(photoScreen);	},})
